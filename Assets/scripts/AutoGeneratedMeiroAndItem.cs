using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.AI;

public class AutoGeneratedMeiroAndItem : MonoBehaviour
{
    [Tooltip("配列の一番最後を取得するため、確率の最低値、スタートのZ軸の座標、棒倒しの際に上下左右の座標を見る際、に使用する変数")]
    const int _one = 1;
    [Tooltip("棒倒しの座標を2飛ばしで行うため、道と壁を決める際のループ一回目を確認するため、ゴールのX軸の座標の最大値を求めるため、配列の横の要素数の半分を求めるため、に使用する変数")]
    const int _two = 2;
    [Tooltip("確率の最大値を定義するために使用する変数、定義したい値ー１の値を入れる")]
    const int _thirteen = 13;
    [SerializeField, Header("横幅、5以上の奇数を入れる"),Tooltip("横幅")]
    int _fieldx = 0;
    [SerializeField, Header("縦幅、5以上の奇数を入れる"),Tooltip("縦幅")]
    int _fieldz = 0;
    [Tooltip("ゴールのx軸の位置")]
    int _goalX = 1;
    [Tooltip("横の要素,for文で使用")]
    int _row = 0;
    [Tooltip("縦の要素,for文で使用")]
    int _column = 0;
    [Tooltip("棒を倒す時の確率")]
    int _probability = 0;
    [Tooltip("オブジェクト生成時の間隔、X軸とZ軸のpositionに当てはめ、それぞれX軸は_row、Z軸は_columnをかける")]
    float _generatIntervalXZ = 5.0f;
    [Tooltip("生成時のY軸の高さ")]
    float _itemPosY = 1.0f;
    [Tooltip("生成時のY軸の高さ")]
    float _wallPosY = 2.5f;
    [Tooltip("ゴールのparticleを上向きにするために回転させる角度")]
    float _rotation = -90f;
    [Tooltip("マップ生成時の二次元配列")]
    bool[,] _field;
    [Tooltip("ゴール付近の足場の位置情報、_goalを生成した位置情報に足す")]
    Vector3 _goalFieldPos = new Vector3(5, 2.5f, 5);
    [SerializeField,Header("壁のprefab"),Tooltip("壁のprefab")]
    GameObject _wall;
    [SerializeField,Header("アイテムのprefab"),Tooltip("アイテムのprefab")]
    GameObject _item;
    [SerializeField,Header("ゴールのprefab"),Tooltip("ゴールのprefab")]
    GameObject _goal;
    [SerializeField, Header("ゴール後の足場のprefab"), Tooltip("ゴール後の足場のprefab")]
    GameObject _goalField;
    GameObject _generationWall;
    GameObject _generationItem;
    GameObject _generationGoal;
    [Tooltip("ナビメッシュをマップ生成後にベイクするために使用")]
    NavMeshSurface _navMeshSurface;

    public int Fieldx { get => _fieldx;}
    public int Fieldz { get => _fieldz;}

    // Start is called before the first frame update
    void Start()
    {
        _navMeshSurface = GetComponent<NavMeshSurface>();
        WayAndBorderGenerated();
    }

    /// <summary>
    /// 外壁決め
    /// </summary>
   private void WayAndBorderGenerated()
    {
        _field = new bool[_fieldz, _fieldx];
        for (_column = 0; _column < _fieldz; _column++)//縦幅の数だけループ
        {
            //左右の壁
            _field[_column, 0] = true;
            _field[_column, _fieldx - _one] = true;
        }
        for (_row = 0; _row < _fieldx; _row++)//横幅の数だけループ
        {
            //上下の壁
            _field[0, _row] = true;
            _field[_fieldz - _one, _row] = true;
        }
        WallGenerated(_field);
    }

    /// <summary>内部の道と壁決め</summary>
    private void WallGenerated(bool[,] field)
    {
        for (_column = _two; _column < _fieldz - _one; _column += _two)
        {
            for (_row = _two; _row < _fieldx - _one; _row += _two)
            {
                if (_column == _two)
                {
                    _probability = Random.Range(_one, _thirteen);//ランダムな値（1～12）を与える。３ずつ分けて上下左右が壁かどうかを確認している。
                }
                else
                {
                    _probability = Random.Range(4, _thirteen);//上に置かないように、条件から外れるように4～12で設定。
                }
                field[_column, _row] = true;
                if (_probability <= 3)
                {
                    if (field[_column - _one, _row] == false)//上に壁が無ければ
                    {
                        field[_column - _one, _row] = true;//壁を置く場所として二次元配列をつくる
                    }
                    else if (field[_column - _one, _row] == true)//壁があったら
                    {
                        _row -= _two; //戻ってやり直す
                    }
                }
                if (_probability >= 4 && _probability <= 6)
                {
                    if (field[_column + _one, _row] == false)//下に壁が無ければ
                    {
                        field[_column + _one, _row] = true;
                    }
                    else if (field[_column + _one, _row] == true)
                    {
                        _row -= _two;
                    }
                }
                if (_probability >= 7 && _probability <= 9)
                {
                    if (field[_column, _row - _one] == false)//左に壁が無ければ
                    {
                        field[_column, _row - _one] = true;
                    }
                    else if (field[_column, _row - _one] == true)
                    {
                        _row -= _two;
                    }
                }
                if (_probability >= 10)
                {
                    if (field[_column, _row + _one] == false)//右に壁が無ければ
                    {
                        field[_column, _row + _one] = true;
                    }
                    else if (field[_column, _row + _one] == true)
                    {
                        _row -= _two;
                    }
                }
            }
        }
        StartAndGoalSet(field);
    }
    /// <summary>スタートとゴール決め</summary>
    private void StartAndGoalSet(bool[,] field)
    {
        _goalX = Random.Range(_one, _fieldx - _two);
        if (field[_fieldz - _two, _goalX] == true)//ゴール前が壁の場合
        {
            _goalX = _goalX >= _fieldx / _two ? _goalX - _one : _goalX + _one;
            StartAndGoalSet(field);
            return;
        }
        field[_fieldz - _one, _goalX] = false;//ゴール地点
        field[0, _one] = false;//スタート地点（固定）
        AutoGenerated(field);
    }
    /// <summary>出来上がったマップを生成</summary>
    private void AutoGenerated(bool[,] field)
    {
        for (_column = 0; _column < _fieldz; _column++) //フィールドの縦幅の分だけループする。
        {
            for (_row = 0; _row < _fieldx; _row++) //フィールドの横幅の分だけループする。
            {
                if(_column == _fieldz - _one && _row == _goalX)
                {
                   _generationGoal = Instantiate(_goal, new Vector3(_generatIntervalXZ * _row, 0, _generatIntervalXZ * _column), Quaternion.Euler(_rotation,0,0));
                    Vector3 pos = _generationGoal.transform.position;
                    Instantiate(_goalField, new Vector3(pos.x + _goalFieldPos.x, _goalFieldPos.y, pos.z + _goalFieldPos.z), Quaternion.identity);//高さは壁と同じ
                }
                else if (field[_column, _row] == true)//壁
                {
                    _generationWall = Instantiate(_wall, new Vector3(_generatIntervalXZ * _row, _wallPosY, _generatIntervalXZ * _column), Quaternion.identity);
                    _generationWall.transform.parent = transform;
                }
                else/* if (field[_column, _row] == false)//道*/
                {
                    _generationItem = Instantiate(_item, new Vector3(_generatIntervalXZ * _row, _itemPosY, _generatIntervalXZ * _column), Quaternion.identity);
                    _generationItem.transform.parent = transform;
                }
            }
        }
        _navMeshSurface.BuildNavMesh();//ベイクする。
        GameManager.Instance.EnemyActive();
    }
}
