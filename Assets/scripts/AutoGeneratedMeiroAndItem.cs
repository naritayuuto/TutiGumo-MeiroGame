using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.AI;

public class AutoGeneratedMeiroAndItem : MonoBehaviour
{
    /// <summary>横幅</summary>
    [SerializeField, Header("5以上の奇数")]
    int _fieldx = 0;//棒倒し法のルールとして5以上の奇数。
    /// <summary>縦幅</summary>
    [SerializeField, Header("5以上の奇数")]
    int _fieldz = 0;//棒倒し法のルールとして5以上の奇数。
    [Tooltip("ゴールのx軸の位置")]
    int _goalX = 1;
    /// <summary>for文で使用する変数</summary>
    int _row = 0;//横の要素番号
    /// <summary>for文で使用する変数</summary>
    int _column = 0;//縦の要素番号
    /// <summary>乱数、棒倒しをするときの方向の確率</summary>
    int _probability = 0;
    [Tooltip("オブジェクト生成時の間隔、X軸とZ軸のpositionに当てはめ、それぞれX軸は_row、Z軸は_columnをかける")]
    float _generatIntervalXZ = 5.0f;
    [Tooltip("生成時のY軸の高さ")]
    float _itemPosY = 1.0f;
    [Tooltip("生成時のY軸の高さ")]
    float _wallPosY = 2.5f;
    [Tooltip("ゴールのparticleを上向きにするために回転させる角度")]
    float _rotation = -90f;
    [Tooltip("ゴール付近の足場の位置情報、_goalを生成した位置情報に足す")]
    Vector3 _goalFieldPos = new Vector3(5, 2.5f, 5);
    [SerializeField,Header("壁のprefab"),Tooltip("壁のprefab")]
    GameObject _wall;
    [SerializeField,Header("アイテムのprefab"),Tooltip("アイテムのprefab")]
    GameObject _item;
    [SerializeField,Header("ゴールのprefab"),Tooltip("ゴールのprefab")]
    GameObject _goal;
    [SerializeField, Header("ゴール後の足場のprefab"), Tooltip("ゴール後の足場のprefab")]
    GameObject _goalField;
    GameObject _generationWall;
    GameObject _generationItem;
    GameObject _generationGoal;
    NavMeshSurface _navMeshSurface;
    // Start is called before the first frame update
    void Start()
    {
        _navMeshSurface = GetComponent<NavMeshSurface>();
        WayAndBorderGenerated();
        _navMeshSurface.BuildNavMesh();
    }

    void WayAndBorderGenerated()
    {
        bool[,] field = new bool[_fieldz, _fieldx];
        for (_column = 0; _column < _fieldz; _column++)//縦幅の数だけループ
        {
            //左右の外壁（1）の生成
            field[_column, 0] = true;
            field[_column, _fieldx - 1] = true;
        }
        for (_row = 0; _row < _fieldx; _row++)//横幅の数だけループ
        {
            //上下の外壁（1）の生成
            field[0, _row] = true;
            field[_fieldz - 1, _row] = true;
        }
        WallGenerated(field);
    }

    void WallGenerated(bool[,] field)
    {
        for (_column = 2; _column < _fieldz - 1; _column += 2)
        {
            for (_row = 2; _row < _fieldx - 1; _row += 2)
            {
                if (_column == 2)
                {
                    _probability = Random.Range(1, 13);//ランダムな値（1～12）を与える。３ずつ分けて上下左右が壁かどうかを確認している。
                }
                else
                {
                    _probability = Random.Range(4, 13);
                }
                field[_column, _row] = true;
                if (_probability <= 3)
                {
                    if (field[_column - 1, _row] == false)//上に壁が無ければ
                    {
                        field[_column - 1, _row] = true;//壁を置く場所として二次元配列をつくる
                    }
                    else if (field[_column - 1, _row] == false)//壁があったら
                    {
                        _row -= 2; //戻ってやり直す
                    }
                }
                if (_probability >= 4 && _probability <= 6)
                {
                    if (field[_column + 1, _row] == false)//下に壁が無ければ
                    {
                        field[_column + 1, _row] = true;
                    }
                    else if (field[_column + 1, _row] == false)
                    {
                        _row -= 2;
                    }
                }
                if (_probability >= 7 && _probability <= 9)
                {
                    if (field[_column, _row - 1] == false)//左に壁が無ければ
                    {
                        field[_column, _row - 1] = true;
                    }
                    else if (field[_column, _row - 1] == true)
                    {
                        _row -= 2;
                    }
                }
                if (_probability >= 10)
                {
                    if (field[_column, _row + 1] == false)//右に壁が無ければ
                    {
                        field[_column, _row + 1] = true;
                    }
                    else if (field[_column, _row + 1] == true)
                    {
                        _row -= 2;
                    }
                }
            }
        }
        AutoGenerated(field);
    }

    void AutoGenerated(bool[,] field)
    {
        _goalX = Random.Range(1, _fieldx - 2);
        if (field[_fieldz - 2, _goalX] == true)//ゴール前が壁の場合
        {
            if(_goalX >= _fieldx % 2)
            {
                _goalX++;
            }
            else
            {
                _goalX--;
            }
            AutoGenerated(field);
            return;
        }
        field[0, 1] = false;//スタート地点（固定）
        field[_fieldz - 1, _goalX] = false;//ゴール地点
        for (_column = 0; _column < _fieldz; _column++) //フィールドの縦幅の分だけループする。
        {
            for (_row = 0; _row < _fieldx; _row++) //フィールドの横幅の分だけループする。
            {
                if(_column == _fieldz -1 && _row == _goalX)
                {
                   _generationGoal = Instantiate(_goal, new Vector3(_generatIntervalXZ * _row, 0, _generatIntervalXZ * _column), Quaternion.Euler(_rotation,0,0));
                    Vector3 pos = _generationGoal.transform.position;
                    Instantiate(_goalField, new Vector3(pos.x + _goalFieldPos.x, _goalFieldPos.y, pos.z + _goalFieldPos.z), Quaternion.identity);//高さは壁と同じ
                }
                if (field[_column, _row] == true)//壁なら
                {
                    _generationWall = Instantiate(_wall, new Vector3(_generatIntervalXZ * _row, _wallPosY, _generatIntervalXZ * _column), Quaternion.identity);
                    _generationWall.transform.parent = transform;//子オブジェクトとして生成
                }
                else if (field[_column, _row] == false)
                {
                    _generationItem = Instantiate(_item, new Vector3(_generatIntervalXZ * _row, _itemPosY, _generatIntervalXZ * _column), Quaternion.identity);
                    _generationItem.transform.parent = transform;
                }
            }
        }
    }
}
